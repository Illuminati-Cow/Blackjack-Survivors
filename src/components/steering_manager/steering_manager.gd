class_name Steering_Manager extends Node
# Reference: https://code.tutsplus.com/understanding-steering-behaviors-movement-manager--gamedev-4278t

# Signals

# Public properties
var steering_force : Vector2

# Private properties
var _host : CharacterBody2D
var _max_speed : float
var _max_force : float
var _mass : float
var _debug_mode : bool
class _gizmos:
	static var lead_pos : Line2D = Line2D.new()
	static var target_vel : Line2D = Line2D.new()
	static var host_vel : Line2D = Line2D.new()

func _init(
	host : CharacterBody2D,
	max_speed : float,
	max_force : float,
	mass : float = 1,
	debug_mode : bool = false
):
	_host = host
	steering_force = Vector2.ZERO
	_max_speed = max_speed
	_max_force = max_force
	_mass = mass
	_debug_mode = debug_mode
	# Initialize gizmos
	if debug_mode:
		_gizmos.lead_pos.position = Vector2.ZERO
		_gizmos.host_vel.add_point(Vector2.ZERO, 0)
		_gizmos.host_vel.add_point(Vector2.ZERO, 1)
		_gizmos.host_vel.default_color = Color.GREEN
		_gizmos.host_vel.width = 1
		_gizmos.target_vel.add_point(Vector2.ZERO, 0)
		_gizmos.target_vel.add_point(Vector2.ZERO, 1)
		_gizmos.target_vel.default_color = Color.PURPLE
		_gizmos.target_vel.width = 1
		_host.add_child(_gizmos.host_vel)
		_host.add_child(_gizmos.lead_pos)
		_host.add_child(_gizmos.target_vel)


func seek(target : Vector2, slow_on_approach : bool = false):
	steering_force += _do_seek(target, slow_on_approach)

func _do_seek(target : Vector2, slow_on_approach : bool = false) -> Vector2:
	var force = 0
	var desired_velocity : Vector2 = target - _host.position
	target = target as Vector2
	if not slow_on_approach:
		desired_velocity = desired_velocity.normalized() * _max_speed
	desired_velocity = _truncate(desired_velocity, _max_speed)
	force = desired_velocity - _host.velocity
	return force

func flee(target):
	assert("position" in target)
	steering_force -= seek(target)

func pursue(target : Node):
	assert("position" in target)
	steering_force += _do_pursue(target)
	
func _do_pursue(target) -> Vector2:
	var t_pos = target.position
	
	if "velocity" in target:
		var t_vel = target.velocity
		var lead_factor = _host.position.distance_to(t_pos) / _max_speed
		var lead_pos = t_pos + t_vel * lead_factor
		# update gizmos
		if _debug_mode:
			_gizmos.target_vel.reparent(target)
			_gizmos.target_vel.position = Vector2.ZERO
			_gizmos.target_vel.points[1] = t_vel
			t_pos = lead_pos
	
	return _do_seek(t_pos, false)
	
# Applies the steering forces generated by behaviors called this frame to the
# host's current velocity and then moves it.
# NOTE: Should be called every physics process update that movement is desired	
func move(delta) -> KinematicCollision2D:
	steering_force = _truncate(steering_force, _max_force) * 1 / _mass
	_host.velocity += steering_force
	_host.velocity = _truncate(_host.velocity, _max_speed)
	var collisions = _host.move_and_collide(_host.velocity * delta)
	if _debug_mode:
		_gizmos.host_vel.points[1] = _host.velocity
	steering_force = Vector2.ZERO
	return collisions

# Truncates the vector to a maximum length of the argument max.
func _truncate(vector : Vector2, max_length : float) -> Vector2:
	var v_len = vector.length()
	if v_len > max_length:
		return vector.normalized() * max_length
	return vector
